## 문제

[문제 링크](https://www.codetree.ai/missions/2/problems/remove-k-walls?&utm_source=clipboard&utm_medium=text)

## 풀이

[백트래킹 + BFS 탐색]

1. (102번 줄) 백트래킹으로 K개의 벽을 제거하는 경우를 모두 구한다.
2. (69번 줄) 1단계에서 각 경우마다 선택된 벽들을 제거한다. (해당 위치의 숫자를 `1` -> `0` 변경)
3. (76번 줄) K개의 선택된 벽들을 없앤 상태에서 시작점(`r1, c1`)에서 BFS 탐색을 진행한다.
   이때 각 칸을 이동할 때마다 `steps`에 도착하는 데 걸린 가중치를 `steps`에 기록한다.
4. (87번 줄) BFS 탐색 끝난 후 도착점(`r2, c2`)에 방문했는지(`visited[r2][c2]`) 확인한다.
   - 방문했으면 도착점까지 걸린 시간 구해(`steps[r2][c2]`) 최소 시간으로 갱신한다.
5. (91번 줄) 다음 경우의 BFS 탐색을 위해 visited와 grid를 초기화시킨다.

## 시간 복잡도

- 시간 복잡도 : `O(8^k * N^2)`
  제시된 입력 형식에 따르면 (`0 ≤ k ≤ 입력으로 주어지는 초기 벽의 개수 ≤ 8`), 입력으로 주어지는 초기 벽의 개수는 최대 8개이다. 그래서 최악의 경우 벽은 8개이므로 백트래킹으로 k개의 제거되는 벽을 고르는 경우의 수는 `8^k` 이다. 정확히는 `8 * 7 * 6 * ... k번 반복`. 8개의 벽 중에 하나 고르고, 나머지 7개 중 하나 고르고, 남지 6개 중에 하나씩 고르고... 이 행위를 k번 반복하니까. (맞겠지..?)
- 공간 복잡도 : `O(N^2)`

## 출처

코드트리 > intermediate-low > BFS > 가중치가 동일한 그래프에서의 BFS > k개의 벽 없애기
