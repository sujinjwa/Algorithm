## 문제

[문제 링크](https://www.codetree.ai/missions/2/problems/select-segments-without-overlap?utm_source=clipboard&utm_medium=text)

## 풀이

n개의 선분들로 만들 수 있는 선택된 선분들의 모든 경우를 조회하고, 그 중에서 서로 겹치지 않으면서 가장 선분의 개수가 최댓값인 경우를 구한다.
예를 들어 선분 3개가 `[(1, 2), (3, 4), (5, 6)]` 입력되었다면 모든 선분이 선택되지 않은 `0, 0, 0` 부터 모든 선분이 선택된 `1, 1, 1` 까지 모든 경우를 조회하면서 그때마다 선분의 개수의 최댓값을 갱신한다.

인접한 선분이 있는지 확인하기 위해서는, 선분들을 입력 받은 2차원 배열 lines를 먼저 오름차순 정렬해 주었다. 그리고 모든 선분들의 선택 여부를 결정한 이후에 각 선분들을 하나의 for문으로 순회하면서 인접한 두개의 선분이 서로 겹치는지 확인했다. (인접한 두 선분 중 더 앞에 위치한 선분(`temp[i]`)의 끝점(`e1`)이 뒤에 위치한 선분(`temp[i+1]`)의 시작점(`f2`)보다 크거나 같으면 겹친다.)

## 시간/공간 복잡도

- 시간 복잡도: O(2^N \* N)
- 공간 복잡도: O(N)

각 선분이 선택될지 선택되지 않을지 2가지 경우를 반복해서 결정해야 하며, 선택이 완료되는 경우마다 모든 선분을 한번 순회하며 겹치는 선분이 있는지 확인하는 N의 시간이 필요하므로, 시간 복잡도는 O(2^N \* N)이다.

## 출처

코드트리 > intermediate-low > Backtracking > k개 중 하나를 n번 선택하기(simple)
