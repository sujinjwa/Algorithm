## 문제

[문제 링크](https://www.codetree.ai/missions/2/problems/max-movements-with-direction?utm_source=clipboard&utm_medium=text)

## 풀이

현재 위치(r, c)에서 출발하여 이동할 수 있는 칸을 고르는 함수 choose(curr_num, r, c) 를 선언하였다.
choose(curr_num, r, c) 함수는 현재 위치(r, c)에서 이동 가능한 칸이 있으면 이동한 칸(nx, ny)를 가지고 choose(curr_num + 1, nx, ny)를 호출하는 재귀 함수이다.
따라서 현재 위치에서 이동 가능한 모든 경로의 경우를 확인할 수 있다.

## 아쉬운 점

1. 이 문제가 다른 백트래킹 문제와 다른 점은 언제 이동이 끝날지 확실하게 정의하기가 어렵다는 것이다. (종료조건을 만들 수 없다.)
   나는 `if not can_go(curr_num, r, c)` 라는 조건문을 종료 조건으로 두어 현재 위치 r, c 에서 이동이 가능한지를 확인했는데, 이 로직은 choose 함수 내부의 로직과 동일하여, 똑같은 코드를 두번 쓴다는 단점이 있다.
   이렇게 하는 것보다 종료 조건을 없애고, <b>적절한 때에만 choose 함수 내부에서 choose 함수를 또 호출</b> 하고, <b>이동 횟수의 최댓값은 이동할 때마다 늘 갱신</b>해주는 것이 좋다.

2. 백트래킹 기본 문제를 풀 때 curr_num 같은 파라미터가 쓰여서 습관적으로 이 문제에도 curr_num을 파라미터로 추가해주었는데, 사실 curr_num은 없어도 되는 파라미터이다.
   arr 또한 필요가 없다. curr_num과 arr 모두 없애고, 함수 호출될 때마다 항상 최댓값을 갱신해주는 방법도 있다. 또, 특별히 가능한 경우(이동하고자 하는 위치가 격자를 벗어나지 않고, 현재 숫자보다 큰 숫자 가 있는 곳인 경우)에만 함수 호출을 해주면 탐색 시간을 줄일 수 있다.

## 시간/공간 복잡도

- 시간 복잡도: O(3^(N^2))

  - N의 범위는 1 <= N <= 4 이므로, 각 칸마다 이동할 수 있는 칸의 개수는 최대 3칸이다.
    이때 최악의 경우 이동 횟수는 모든 칸을 방문하는 것이다. 즉, 모든 칸의 개수인 N^2번 반복하여 3칸의 선택지를 고를 수 있다.
    따라서 시간 복잡도는 O(3^(N^2)) 가 된다.

- 공간 복잡도: O(N^2)

## 출처

코드트리 > intermediate-low > Backtracking > k개 중 하나를 n번 선택하기(conditional)
